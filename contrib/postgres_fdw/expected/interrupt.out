Parsed test spec with 3 sessions

starting permutation: s2_begin s2_hang_logins s1_select_remote s3_cancel_s1 s2_commit
step s2_begin: BEGIN;
step s2_hang_logins: LOCK pg_db_role_setting;
step s1_select_remote: SELECT count(*) FROM remote_t1; <waiting ...>
step s3_cancel_s1: 
  SELECT wait_for_s1();
  SELECT pg_cancel_backend(pid) FROM pg_stat_activity WHERE datname = current_database() AND application_name = 'isolation/interrupt/s1';

wait_for_s1
-----------
           
(1 row)

pg_cancel_backend
-----------------
t                
(1 row)

step s1_select_remote: <... completed>
ERROR:  canceling statement due to user request
step s2_commit: COMMIT;

starting permutation: s2_begin s2_hang_logins s1_select_remote s2_commit
step s2_begin: BEGIN;
step s2_hang_logins: LOCK pg_db_role_setting;
step s1_select_remote: SELECT count(*) FROM remote_t1; <waiting ...>
step s2_commit: COMMIT;
step s1_select_remote: <... completed>
count
-----
    0
(1 row)


starting permutation: s2_begin s2_hang_select s1_select_remote s3_cancel_s1 s2_commit
step s2_begin: BEGIN;
step s2_hang_select: LOCK local_t1;
step s1_select_remote: SELECT count(*) FROM remote_t1; <waiting ...>
step s3_cancel_s1: 
  SELECT wait_for_s1();
  SELECT pg_cancel_backend(pid) FROM pg_stat_activity WHERE datname = current_database() AND application_name = 'isolation/interrupt/s1';

wait_for_s1
-----------
           
(1 row)

pg_cancel_backend
-----------------
t                
(1 row)

step s1_select_remote: <... completed>
ERROR:  canceling statement due to user request
step s2_commit: COMMIT;

starting permutation: s2_begin s2_hang_select s1_select_remote s2_commit
step s2_begin: BEGIN;
step s2_hang_select: LOCK local_t1;
step s1_select_remote: SELECT count(*) FROM remote_t1; <waiting ...>
step s2_commit: COMMIT;
step s1_select_remote: <... completed>
count
-----
    0
(1 row)


starting permutation: s2_begin s2_hang_logins s1_select_remote s3_terminate_s1 s2_commit
step s2_begin: BEGIN;
step s2_hang_logins: LOCK pg_db_role_setting;
step s1_select_remote: SELECT count(*) FROM remote_t1; <waiting ...>
step s3_terminate_s1: 
  SELECT wait_for_s1();
  SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = current_database() AND application_name = 'isolation/interrupt/s1';

wait_for_s1
-----------
           
(1 row)

pg_terminate_backend
--------------------
t                   
(1 row)

step s1_select_remote: <... completed>
FATAL:  terminating connection due to administrator command
server closed the connection unexpectedly
	This probably means the server terminated abnormally
	before or while processing the request.

step s2_commit: COMMIT;
